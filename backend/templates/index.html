<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MVG Transport Display</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link 
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" 
    rel="stylesheet"
  >

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>

  <style>
    :root {
      --font-family: "Inter", sans-serif;
      --bg-gradient: linear-gradient(135deg, #597d69, #95ab96);
      
      /* Adjusted card backgrounds for better contrast */
      --card-bg: rgba(255,255,255,0.1);
      --card-border: 1px solid rgba(255,255,255,0.15);
      --card-blur: blur(12px);

      /* Enhanced text contrast */
      --text-primary: #ffffff;
      --text-secondary: #e0e5e2;
      --accent: #dde7e3; 
      
      --status-green: #90E1A8;
      --status-yellow: #FFE17D;
      --status-red: #FF9B9B;

      --shadow: 0 8px 16px rgba(0,0,0,0.2);
      --transition-fast: 0.3s;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family);
      background: var(--bg-gradient);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    #bg-canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
    }

    .container {
      position: relative;
      z-index: 1;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* Redesigned header section */
    .header {
      position: relative;
      background: var(--card-bg);
      backdrop-filter: var(--card-blur);
      border: var(--card-border);
      border-radius: 16px;
      padding: 2rem;
      margin-bottom: 2rem;
    }

    .station-name {
      font-size: 2.4rem;
      font-weight: 700;
      text-align: center;
      margin-bottom: 1.5rem;
      letter-spacing: -0.5px;
    }

    .header-info {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      text-align: center;
    }

    .info-block {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* Centers everything vertically */
      gap: 0.5rem; /* Adjusts spacing between elements */
      padding: 1rem;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border: var(--card-border);
      min-width: 120px; /* Ensures consistent width across all blocks */
      text-align: center; /* Ensures text alignment is consistent */
    }

    .info-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .info-value {
      font-size: 2rem;
      font-weight: 600;
    }

    .info-secondary {
      font-size: 1rem;
      color: var(--text-secondary);
    }

    .weather-icon {
      width: 72px; /* Adjust size if needed */
      height: 72px;
      margin-top: -1.2rem;
      margin-bottom: -1.2rem;
    }

    .weather-description {
      font-size: 1rem;
      color: var(--text-secondary);
      text-align: center;
      text-transform: capitalize; /* Capitalizes each word */
    }

    /* Enhanced departure cards */
    .departures-section {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .direction-block {
      background: var(--card-bg);
      backdrop-filter: var(--card-blur);
      border: var(--card-border);
      border-radius: 16px;
      padding: 1.5rem;
    }

    .direction-title {
      text-align: center;
      font-size: 1.6rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      color: var(--text-primary);
    }

    .direction-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .departure-card {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      border: var(--card-border);
      padding: 0rem; /* Keep some padding for content breathing room */
      display: grid;
      grid-template-columns: 80px 1fr 80px; /* Dynamically size status bar, fixed sizes for others */
      grid-template-rows: 1fr; /* Single row alignment */
      align-items: center; /* Vertical alignment of all content */
      gap: 1rem; /* Space between items */
      height: 80px; /* Fixed height for consistency */
    }

    .departure-card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow);
      background: rgba(255, 255, 255, 0.2);
    }

    .status-bar {
      width: 8px;
      height: 100%;
      border-radius: 4px;
      background: #999;
      grid-column: 1; /* Assign status bar to the first column */
      align-self: center;
    }

    .connection-good   .status-bar { background: var(--status-green);   }
    .connection-medium .status-bar { background: var(--status-yellow);  }
    .connection-poor   .status-bar { background: var(--status-red);     }
    .connection-none   .status-bar { background: #999; }

    .line-box {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      width: 80px;
      height: 100%;
      display: flex;
      align-items: center; /* Center vertically */
      justify-content: center; /* Center horizontally */
      font-size: 2rem;
      font-weight: 700;
      color: var(--text-primary);
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      grid-column: 2; /* Line box in the second column */
    }

    .destination {
      display: flex;
      align-items: center; /* Center vertically */
      font-size: 1.4rem;
      font-weight: 500;
      color: var(--text-primary);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      grid-column: 3; /* Destination text in the third column */
      height: 100%
    }

    .minutes {
      display: flex;
      align-items: center; /* Center vertically */
      justify-content: center; /* Center horizontally */
      font-size: 2.4rem;
      font-weight: 700;
      color: var(--text-primary);
      text-align: right;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      grid-column: 4; /* Minutes in the fourth column */
      height: 100%
    }

    .minutes.soon        { color: var(--status-red);    }
    .minutes.approaching { color: var(--status-yellow); }
    .minutes.normal      { color: var(--status-green);  }

    .placeholder {
      opacity: 0.7;
      font-style: italic;
      color: var(--text-secondary);
    }

    .last-updated {
      text-align: center;
      margin-top: 2rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .stale {
      color: var(--status-red) !important;
    }

    @media (max-width: 768px) {
      .header-info {
        grid-template-columns: 1fr; /* Stacks the blocks vertically */
        gap: 1rem;
      }
    }

      .departure-card {
        grid-template-columns: 8px 60px 1fr 80px;
        height: auto;
        gap: .8rem;
        padding: 1rem;
      }

      .line-box {
        width: 60px;
        height: 60px;
        font-size: 1.6rem;
      }

      .destination {
        font-size: 1.2rem;
      }

      .minutes {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="bg-canvas"></canvas>

  <div class="container">
    <div class="header" id="station-toggle">
      <div class="station-name">PRINZ-EUGEN-PARK</div>
      <div class="header-info">
        <!-- Zeit (Time) Block -->
        <div class="info-block">
          <span class="info-label" data-translation-key="time"></span> <!-- Time will be translated -->
          <span class="info-value time-big"></span>
          <span class="info-secondary date-small"></span>
        </div>
      
        <!-- Temperatur (Temperature) Block -->
        <div class="info-block">
          <span class="info-label" data-translation-key="temperature"></span> <!-- Temperature will be translated -->
          <span class="info-value weather-temp">--°C</span>
          <span class="info-secondary weather-forecast">(↑--° ↓--°)</span>
        </div>
      
        <!-- Wetter (Weather) Block -->
        <div class="info-block">
          <span class="info-label" data-translation-key="weather"></span> <!-- Weather will be translated -->
          <img class="weather-icon" src="" alt="Wetter" />
          <span class="weather-description">--</span>
        </div>
      </div>
    </div>

    <div class="departures-section">
      <div class="direction-block">
        <h2 class="direction-title" id="hdr-outward">Stadtauswärts</h2>
        <div class="direction-list" id="dep-outward"></div>
      </div>
      <div class="direction-block">
        <h2 class="direction-title" id="hdr-inward">Innenstadt</h2>
        <div class="direction-list" id="dep-inward"></div>
      </div>
    </div>

    <div class="last-updated"></div>
  </div>
  <script>
    /*
      ------------------------------------------------
      THREE.js for the 3D background
      ------------------------------------------------
    */
    const canvas = document.getElementById('bg-canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth/window.innerHeight, 0.1, 1000
    );
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.BufferGeometry();
    const count = 600;
    const positions = new Float32Array(count * 3);

    for (let i=0; i<count*3; i++){
      positions[i] = (Math.random() - 0.5)*5;
    }

    geometry.setAttribute(
      'position', new THREE.BufferAttribute(positions, 3)
    );
    const material = new THREE.PointsMaterial({
      size: 0.008,
      color: '#fff',
      transparent: true,
      opacity: 0.65
    });
    const starField = new THREE.Points(geometry, material);
    scene.add(starField);

    camera.position.z = 2;
    function animateBG() {
      requestAnimationFrame(animateBG);
      starField.rotation.y += 0.0005;
      starField.rotation.x += 0.0003;
      renderer.render(scene, camera);
    }
    animateBG();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /*
      ------------------------------------------------
      MAIN FUNCTIONALITY (Partial-Diff Logic)
      ------------------------------------------------
    */
    let refreshTime = null;
    let language = 'DE';
    const WALKING_TIME = 6;

    let outwardState = {};
    let inwardState  = {};

    const translations = {
      DE: {
        outward: "Stadtauswärts",
        inward: "Innenstadt",
        lastUpdated: "Letzte Aktualisierung vor",
        seconds: "Sekunden",
        errorLoading: "Fehler beim Laden der Daten.",
        time: "Zeit",  // Translation for "zeit"
        temperature: "Temperatur",  // Translation for "temp"
        weather: "Wetter"  // Translation for "wetter"
      },
      EN: {
        outward: "Outbound",
        inward: "Inbound",
        lastUpdated: "Last updated",
        seconds: "seconds",
        errorLoading: "Error loading data.",
        time: "Time",  // Translation for "zeit"
        temperature: "Temperature",  // Translation for "temp"
        weather: "Weather"  // Translation for "wetter"
      }
    };

    function sel(id) {
      return document.getElementById(id);
    }
    function qsel(selector) {
      return document.querySelector(selector);
    }

    // Time/Date
    function formatDateTime() {
      const now = new Date();
      const locale = (language === 'DE') ? 'de-DE' : 'en-GB';

      const timeStr = now.toLocaleTimeString(locale, {
        hour: '2-digit',
        minute: '2-digit'
      });
      qsel('.time-big').textContent = timeStr;

      const weekday = now.toLocaleDateString(locale, {
        weekday: 'long'
      });
      const dateStr = now.toLocaleDateString(locale, {
        day: 'numeric',
        month: 'long'
      });
      qsel('.date-small').textContent = `${weekday}, ${dateStr}`;
    }

    // Weather
    function updateWeather(weather) {
  if (!weather) return;

  qsel('.weather-temp').textContent = `${weather.temp}°C`;
  qsel('.weather-forecast').textContent = `(↑${weather.temp_max}° ↓${weather.temp_min}°)`;

  const icon = qsel('.weather-icon');
  icon.src = `https://openweathermap.org/img/wn/${weather.icon}.png`;

  // Toggle between English and German descriptions
  const description = language === 'DE' ? weather.description_de : weather.description_en;
  qsel('.weather-description').textContent = capitalizeWords(description);
}

function capitalizeWords(str) {
  return str.replace(/\b\w/g, char => char.toUpperCase());
}

    function capitalizeWords(str) {
      return str.replace(/\b\w/g, char => char.toUpperCase());
    }

    function capitalizeWords(str) {
      return str.replace(/\b\w/g, char => char.toUpperCase());
    }

    // Connection / minute helpers
    function getConnectionClass(conn) {
      if (!conn) return 'connection-none';
      return `connection-${conn.status}`;
    }
    function getMinuteColor(minutes) {
      if (minutes <= (WALKING_TIME - 1)) return 'soon';
      if (minutes <= (WALKING_TIME + 1)) return 'approaching';
      if (minutes <= (WALKING_TIME + 3)) return 'normal';
      return '';
    }

    // Unique ID
    function getTramId(tram, i, direction) {
      return `${direction}-${i}-${tram.line}-${tram.destination}`;
    }

    // CREATE / UPDATE / REMOVE
    function createTramCard(tram) {
      const card = document.createElement('div');
      card.className = `departure-card ${getConnectionClass(tram.connection)}`;
      card.innerHTML = `
        <div class="status-bar"></div>
        <div class="line-box">${tram.line}</div>
        <div class="destination">${tram.destination}</div>
        <div class="minutes ${getMinuteColor(tram.minutes)}">${tram.minutes}</div>
      `;
      return card;
    }
    function createPlaceholderCard() {
      const card = document.createElement('div');
      card.className = `departure-card connection-none`;
      card.innerHTML = `
        <div class="status-bar"></div>
        <div class="line-box">--</div>
        <div class="destination placeholder">Keine Abfahrt</div>
        <div class="minutes">--</div>
      `;
      return card;
    }
    function updateTramCard(card, tram) {
      card.className = `departure-card ${getConnectionClass(tram.connection)}`;
      card.querySelector('.line-box').textContent = tram.line;
      card.querySelector('.destination').textContent = tram.destination;
      const minEl = card.querySelector('.minutes');
      minEl.textContent = tram.minutes;
      minEl.className = `minutes ${getMinuteColor(tram.minutes)}`;
    }
    function removeTramCard(card) {
      card.remove();
    }

    // Render partial diff
    function renderTrams(container, oldState, newArr, directionKey) {
      const newOrderIds = [];
      for (let i = 0; i < 4; i++) {
        const tram = newArr[i];
        if (tram) {
          const id = getTramId(tram, i, directionKey);
          newOrderIds.push(id);
          if (!oldState[id]) {
            const c = createTramCard(tram);
            container.appendChild(c);
            oldState[id] = { data: tram, cardElement: c };
          } else {
            updateTramCard(oldState[id].cardElement, tram);
          }
        } else {
          // Add placeholders for missing trams
          const pid = `placeholder-${directionKey}-${i}`;
          newOrderIds.push(pid);
          if (!oldState[pid]) {
            const ph = createPlaceholderCard();
            container.appendChild(ph);
            oldState[pid] = { data: null, cardElement: ph };
          }
        }
      }

      // Ensure elements are reordered correctly
      newOrderIds.forEach(id => {
        if (oldState[id]) {
          container.appendChild(oldState[id].cardElement);
        }
      });

      // Remove any old cards not in the new order
      for (const [id, obj] of Object.entries(oldState)) {
        if (!newOrderIds.includes(id)) {
          removeTramCard(obj.cardElement);
          delete oldState[id];
        }
      }
    }

    // Update display
    function updateDisplay(data) {
      if (!data) return;
      updateWeather(data.weather);
      formatDateTime();

      const outArr = data.trams.northbound;
      const inArr  = data.trams.southbound;

      renderTrams(sel('dep-outward'), outwardState, outArr, 'outward');
      renderTrams(sel('dep-inward'), inwardState, inArr, 'inward');

      refreshTime = Math.floor(Date.now() / 1000);
      qsel('.last-updated').textContent = 
        `${translations[language].lastUpdated} 0 ${translations[language].seconds}`;
    }

    // Fetch
    async function fetchData() {
      try {
        const res = await fetch('/api/data');
        if (!res.ok) throw new Error(res.statusText);
        const data = await res.json();
        updateDisplay(data);
      } catch (error) {
        console.error(error);
        sel('dep-outward').textContent = translations[language].errorLoading;
        sel('dep-inward').textContent  = translations[language].errorLoading;
      }
    }

    // Language toggle
    sel('station-toggle').addEventListener('click', () => {
      language = (language === 'DE') ? 'EN' : 'DE';
      sel('hdr-outward').textContent = translations[language].outward;
      sel('hdr-inward').textContent = translations[language].inward;

      document.querySelectorAll('.info-label').forEach(label => {
        const key = label.textContent.trim().toLowerCase();
        label.textContent = translations[language][key] || label.textContent;
      });

      formatDateTime(); // Update time display for the new language

      // Immediately update the weather description
      if (weather_service.cache) {
        const cachedWeather = weather_service.cache; // Access cached weather data
        const description = language === 'DE' ? cachedWeather.description_de : cachedWeather.description_en;
        qsel('.weather-description').textContent = capitalizeWords(description);
      }
    });

    // Intervals
    setInterval(formatDateTime, 1000);

    setInterval(() => {
      if (!refreshTime) return;
      const now = Math.floor(Date.now() / 1000);
      const secs = now - refreshTime;
      const lu = qsel('.last-updated');
      lu.textContent =
        `${translations[language].lastUpdated} ${secs} ${translations[language].seconds}`;
      lu.classList.toggle('stale', secs > 45);
    }, 1000);

    fetchData();
    setInterval(fetchData, 15000);
  </script>
</body>
</html>